/* Generated by: JJTree: Do not edit this line. BSHLambda.java Version 1.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=BSH,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/*****************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one                *
 * or more contributor license agreements.  See the NOTICE file              *
 * distributed with this work for additional information                     *
 * regarding copyright ownership.  The ASF licenses this file                *
 * to you under the Apache License, Version 2.0 (the                         *
 * "License"); you may not use this file except in compliance                *
 * with the License.  You may obtain a copy of the License at                *
 *                                                                           *
 *     http://www.apache.org/licenses/LICENSE-2.0                            *
 *                                                                           *
 * Unless required by applicable law or agreed to in writing,                *
 * software distributed under the License is distributed on an               *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY                    *
 * KIND, either express or implied.  See the License for the                 *
 * specific language governing permissions and limitations                   *
 * under the License.                                                        *
 *                                                                           *
 *                                                                           *
 * This file is part of the BeanShell Java Scripting distribution.           *
 * Documentation and updates may be found at http://www.beanshell.org/       *
 * Patrick Niemeyer (pat@pat.net)                                            *
 * Author of Learning Java, O'Reilly & Associates                            *
 *                                                                           *
 *****************************************************************************/

package bsh;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Proxy;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Make a proxy class to wrap the parameters and body for this lambda.
 */
public class BSHLambda extends SimpleNode {

    /**
     * Counter used to make unique method names
     */
    static int count;

    public BSHLambda(int id) {
        super(id);
    }

    @Override
    public Object eval(CallStack callstack, Interpreter interpreter )
        throws EvalError {

        // Require that there is a cast expression in the AST above this node
        BSHType cast = findCastParent((SimpleNode)this.parent);
        if (cast == null)
            throw new EvalException("Lambda requires an explicit cast to the functional interface", this, callstack);

        Class<?> targetType;
        try {
            targetType = cast.getType(callstack, interpreter);
        } catch (EvalError ee) {
            throw new EvalException("Could not resolve functional interface for lambda", this, callstack, ee);
        }
        if (targetType == null)
            throw new EvalException("Could not infer target type for lambda, requires explicit cast or type declaration", this, callstack);

        // Check for Single Abstract Method
        Method sam = findSAM(targetType);
        if (sam == null)
            throw new EvalException("Could not find single abstract method in class " + targetType.getName(),
                    this, callstack);

        // Get return and parameter types
        Class<?> returnType = sam.getReturnType();
        BSHFormalParameters fp = (BSHFormalParameters) jjtGetChild(0);
        Class<?>[] paramTypes = sam.getParameterTypes();
        if (fp.jjtGetNumChildren() != paramTypes.length)
            throw new EvalException("Number of lambda parameters does not match to single abstract method "+
                    targetType.getSimpleName()+"."+sam.getName(), this, callstack);

        /*
         * If the lambda body is not a block then wrap it in one
         */
        BSHBlock block;
        SimpleNode bdy = (SimpleNode) jjtGetChild(1);
        if (bdy instanceof BSHBlock)
            block = (BSHBlock) bdy;
        else {
            /*
             * If the expression does not have a return statement then add one
             */
            if (sam.getReturnType() != Void.class && findReturnNode(bdy) == null) {
                BSHReturnStatement ret = new BSHReturnStatement(ParserTreeConstants.JJTRETURNSTATEMENT);
                ret.add(bdy);
                bdy = ret;
            }
            block = new BSHBlock(ParserTreeConstants.JJTBLOCK);
            block.add(bdy);
        }

        // Construct a method and wrap it in a proxy for the functional interface
        BshMethod bshMethod =
                new BshMethod("lambda" + (count++),
                        returnType,
                        fp.getParamNames(),
                        paramTypes,
                        fp.getParamModifiers(),
                        block,
                        callstack.top(),
                        new Modifiers(Modifiers.METHOD),
                        false);

        return Proxy.newProxyInstance(getClass().getClassLoader(),
                new Class<?>[] {targetType},
                new ScriptHandler(this, targetType, sam.getName(), bshMethod, interpreter, callstack));
    }

    /**
     * Search up the AST for a BSHCastExpression node.  Only allow PrimaryPrefix and Assignment
     * nodes on the path to the cast.
     * @param node  start with the parent of the Lambda node
     * @return the BSHCastExpression node
     */
    private BSHType findCastParent(SimpleNode node) {
        while(node != null) {
            if (node instanceof BSHCastExpression)
                return (BSHType) node.jjtGetChild(0);
            else if (! ((node instanceof BSHPrimaryExpression) ||
                    (node instanceof BSHAssignment && ((BSHAssignment)node).operator == null)))
                return null;
            node = (SimpleNode) node.parent;
        }
        return null;
    }

    /**
     * Search the declared methods of an interface for a single abstract method
     * @param targetType The interface to search
     * @return the single abstract method in the interface, or null if not found
     */
    private Method findSAM(Class<?> targetType) {
        List<Method> methods = Arrays.stream(targetType.getDeclaredMethods())
                .filter(m -> Modifier.isAbstract(m.getModifiers()))
                .collect(Collectors.toList());
        if (methods.size() == 1)
            return methods.get(0);
        else
            return null;
    }

    /**
     * Do a depth first search and return the first BSHReturnStatement
     * found in this tree, or null if none found/
     * @param root the root of the ast to search
     */
    static SimpleNode findReturnNode(SimpleNode root) {
        if (root instanceof BSHReturnStatement)
            return root;
        for (Node n : root.jjtGetChildren()) {
            SimpleNode returnNode = findReturnNode((SimpleNode)n);
            if (returnNode != null)
                return returnNode;
        }
        return null;
    }

    /**
     * The invocation handler that calls the beanshell lambda method
     */
    private static class ScriptHandler implements InvocationHandler {
        private final SimpleNode node;
        private final Class<?> targetType;
        private final String methodName;
        private final BshMethod bshMethod;
        private final Interpreter interpreter;
        private final CallStack callstack;
        private final Map<String, Method> methods;
        public ScriptHandler(SimpleNode node, Class<?> targetType, String methodName, BshMethod bshMethod, Interpreter interpreter, CallStack callstack) {
            this.node = node;
            this.targetType = targetType;
            this.methodName = methodName;
            this.bshMethod = bshMethod;
            this.interpreter = interpreter;
            this.callstack = callstack;
            methods = new HashMap<>();
            for(Method method: targetType.getDeclaredMethods())
                methods.put(method.getName(), method);
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args)
                throws Throwable {
            String searchName = method.getName();
            if (methodName.equals(searchName)) {
                // Call the lambda method body as a BeanShell method
                Object val = bshMethod.invoke(args, interpreter, callstack, null);
                Object v2 = Types.castObject(val, method.getReturnType(), Types.CAST);
                return Primitive.unwrap(v2);
            } else {
                if ("toString".equals(searchName) && (args == null || args.length == 0))
                    return proxy.getClass().getName()+"@"+System.identityHashCode(proxy);
                else if ("hashCode".equals(searchName) && (args == null || args.length == 0))
                    return System.identityHashCode(proxy);
                else if ("equals".equals(searchName) && (args != null && args.length == 1))
                    return proxy == args[0];
                else {
                    // Call the default and static methods on the interface
                    Method m = methods.get(method.getName());
                    if (m == null)
                        throw new EvalException("No method " + method.getName() + " with "+args.length+" arguments in class " + targetType.getName(), node, callstack);
                    try {
                        Object val = m.invoke(proxy, args);
                        return val;
                    } catch (Exception ex) {
                        throw new EvalException("Error invoking method '" + method.getName() + "'", node, callstack, ex);
                    }
                }
            }
        }
    }
}
/* JavaCC - OriginalChecksum=e4a1d5c6d28f353ca1c114bf2e2ef44d (do not edit this line) */
